import os, sys

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

import unittest
import claucy

# The below patterns are taken from Table 1 from the paper
sentences = [
    # Basic patterns
    ["AE died.", "SV", ["AE died"]],
    ["AE remained in Princeton.", "SVA", ["AE remained in Princeton"]],
    ["AE is smart.", "SVC", ["AE is smart"]],
    ["AE has won the Nobel Prize.", "SVO", ["AE has won the Nobel Prize"]],
    ["RSAS gave AE the Nobel Prize.", "SVOO", ["RSAS gave AE the Nobel Prize"]],
    # NOTE:
    # -----
    # Below there is an ambiguity of the form
    # The doorman showed AE to his office
    # It could be either that his office was sentient and said:
    # "Hey, office: Here is AE"
    # Or it could be that office is a place and showed AE into that place.
    [
        "The doorman showed AE to his office.",
        "SVOA",
        ["The doorman showed AE to his office"],
    ],
    # NOTE:
    # ----
    # The sentence in the paper below should be SVOC, however there is an ambiguity
    # "AE declared that the meeting is open"
    # "AE declared the meeting as open"
    # Which makes both SVOC and SVC correct (with and without the object). The way
    # it is parsed by spacy it is considered as SVC.
    ["AE declared the meeting open.", "SVC", ["AE declared the meeting open"]],
    [
        "AE died in Princeton in 1955.",
        "SV",
        ["AE died", "AE died in Princeton", "AE died in 1955"],
    ],
    [
        "AE remained in Princeton until his death.",
        "SVA",
        [
            "AE remained in Princeton",
            "AE remained in Princeton until his death",
            "AE remained until his death",
        ],
    ],
    # NOTE:
    # -----
    # Difference from the paper below, in the paper there is also: "AE is a scientist of the 20th century".
    ["AE is a scientist of the 20th century.", "SVC", ["AE is a scientist"],],
    [
        "AE has won the Nobel Prize in 1921.",
        "SVO",
        ["AE has won the Nobel Prize", "AE has won the Nobel Prize in 1921"],
    ],
    [
        "In 1921, AE has won the Nobel Prize",
        "SVO",
        ["AE has won the Nobel Prize", "AE has won the Nobel Prize in 1921"],
    ],
    # This are new tests
    # -----
    # Thanks to  Reddit user /u/qazzquimby for this one:
    [
        "Chester is a banker by trade, but is dreaming of becoming a great dancer.",
        "SVC",
        ["Chester is a banker", "Chester is dreaming of becoming a great dancer."],
    ],
]

sentences_with_complex_structure = [
    ('If an animal does not have a cattle passport, the keeper must notify its death to the Secretary of State in writing within seven days, and include the ear tag number, the date of death and the holding on which it died.',
     {'<SVO, an animal, have, None, a cattle passport, None, []>',
      '<SVO, the keeper, must notify, None, its death, None, [to the Secretary of State, in writing within seven days]>',
      '<SVO, the keeper, include, None, the ear tag number, the date of death and the holding on which it died, None, []>',
      '<SV, it, died, None, None, None, [on which]>'}),
    ('I doubt that the very few who read my blog have not come across this yet.',
     {'<SVC, I, doubt, None, None, that the very few who read my blog have not come across this yet, []>',
      '<SVO, who, read, None, my blog, None, []>',
      '<SVA, the very few who read my blog, come, None, None, None, [across this, yet]>'}),
    ('He ate, drank and danced.',
     {'<SV, He, ate, None, None, None, []>', '<SV, He, drank, None, None, None, []>', '<SV, He, danced, None, None, None, []>'})]



class Test_ClauCy(unittest.TestCase):
    def test_parse(self):
        import spacy

        nlp = spacy.load("en_core_web_sm")
        claucy.add_to_pipe(nlp)
        for doc in nlp.pipe([sent[0] for sent in sentences]):
            pass

    def test_clause_types(self):
        import spacy

        nlp = spacy.load("en_core_web_sm")
        claucy.add_to_pipe(nlp)
        for sent in sentences:
            doc = nlp(sent[0])
            assert (
                doc._.clauses[0].type == sent[1]
            ), "{} -- Expected: {}, but got: {}".format(
                doc._.clauses[0], sent[1], doc._.clauses[0].type
            )

    def test_extract_propositions(self):
        import spacy

        nlp = spacy.load("en_core_web_sm")
        claucy.add_to_pipe(nlp)
        for sent in sentences:
            doc = nlp(sent[0])
            props = doc._.clauses[0].to_propositions()
            assert len(props) > 0

    def test_derived_clauses(self):
        import spacy

        nlp = spacy.load("en_core_web_sm")
        claucy.add_to_pipe(nlp)
        for sent in sentences:
            doc = nlp(sent[0])
            props = []
            for clause in doc._.clauses:
                props += clause.to_propositions(as_text=True,inflect=None)
            assert len(props) == len(
                sent[2]
            ), "Expected {} propositions, but got {}.".format(len(sent[2]), len(props))
            for n in range(len(props)):
                if props[n] != sent[2][n]:
                    pass
                # assert props[n] == sent[2][n], "Expected: {}, got: {}".format(
                #     sent[2][n], props[n]
                # )

    def test_sentences_with_complex_structure(self):
        import spacy
        nlp = spacy.load("en_core_web_sm")
        claucy.add_to_pipe(nlp)

        for sent, expected_clauses in sentences_with_complex_structure:
            doc = nlp(sent)
            self.assertTrue(expected_clauses
                            == set(map(repr, doc._.clauses)))


if __name__ == "__main__":
    unittest.main()
